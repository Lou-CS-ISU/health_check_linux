#! /opt/VRTSperl/bin/perl

BEGIN{
	push(@INC, "/usr/share/perl5");
}

use lib '/usr/local/ab/tlk/lib/perl5/site_perl/5.20.2';
use Time::Local;
require 'ctime.pl';

if ( $#ARGV eq -1 ) {
	print $0 . " {date string}\n";
	exit 1;
}

my $time = join ' ', @ARGV;

sub myctime {
    package myctime;

    local($ltime) = @_;
    local($[) = 0;
    local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);

    # Determine what time zone is in effect.
    # Use GMT if TZ is defined as null, local time if TZ undefined.
    # There's no portable way to find the system default timezone.

    $TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : '';
    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
        ($TZ eq 'GMT') ? gmtime($ltime) : localtime($ltime);

    # Hack to deal with 'PST8PDT' format of TZ
    # Note that this can't deal with all the esoteric forms, but it
    # does recognize the most common: [:]STDoff[DST[off][,rule]]

    if($TZ=~/^([^:\d+\-,]{3,})([+-]?\d{1,2}(:\d{1,2}){0,2})([^\d+\-,]{3,})?/){
        $TZ = $isdst ? $4 : $1;
    }
    $TZ .= ' ' unless $TZ eq '';

    $year += 1900;
#    sprintf("%s %s %2d %2d:%02d:%02d %s%4d\n",
#      $DoW[$wday], $MoY[$mon], $mday, $hour, $min, $sec, $TZ, $year);
    sprintf("%4d%02d%02d_%02d%02d%02d",
      $year, $mon+1, $mday, $hour, $min, $sec);
}
1;

# $time = "Wed Mar  19 17:30:00 2008 EDT";
# $time = "Wed 12 Jan 2011 05:31:50 AM EST";

################

$TIME=time();

use Date::Calc qw(:all);

@cr_datetime=split(/ /, $time);
@cr_time=split(/:/, $cr_datetime[4]);
$cr_sec=$cr_time[2];
$cr_min=$cr_time[1];
$cr_hour=$cr_time[0];
$cr_day=$cr_datetime[1];
$cr_month=Decode_Month($cr_datetime[2]);
$cr_year=$cr_datetime[3];

my $secs = timelocal($cr_sec,$cr_min,$cr_hour,$cr_day,$cr_month-1,$cr_year);
$DAYS=int(($TIME - $secs)/3600/24);

print myctime($secs) . " " . $DAYS ."\n";
